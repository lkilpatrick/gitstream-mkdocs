{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"/:\\ gitStream","text":"<p>gitStream automates your reviews, so you can focus human effort on what matters most. Not all code changes are equal. Some pull requests can be automated, like changes using a specific API (deprecated, sensitive), changes that are non-functional, like docs or tests, or even reformatting code. Automate these reviews to reduce context switch by assigning specific people to review, approving, or even merging simple changes that passed all checks and more.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Take these 3 steps to see how gitStream works, later on you can learn about the <code>.cm</code> file, see some automation examples and learn how to create and edit your automations.</p> <ol> <li>Get gitStream for free from GitHub marketplace</li> <li>Add these 2 files <code>.cm/gitstream.cm</code> and <code>.github/workflows/gitstream.yml</code> to your repo</li> <li>Open a new PR to see gitStream in action (You don\u2019t have to merge it)</li> </ol>"},{"location":"#features","title":"Features","text":"<p>Multiple conditions</p> <ul> <li>Files names and path</li> <li>Code changes</li> <li>Detect specific changes using regex expressions</li> <li>Check for formatting changes</li> <li>Calculate PR complexity </li> </ul> <p>Review automations</p> <ul> <li>Add labels and comments to PR</li> <li>Approve or Merge PRs</li> <li>Request Changes with contextual content</li> <li>and more...</li> </ul> <p>Easy to configure and powerful</p> <ul> <li>Review automation as code <code>.cm</code> files</li> <li>Based on Jinja2 template engine</li> <li>Rich expressions support </li> <li>Powerful built-in filter functions</li> </ul>"},{"location":"#continuous-merge","title":"Continuous Merge","text":"<p>Continuous Merge (CM) is the practice of automating the merge path by classifying pull requests based on change type, size, and complexity to allow work to flow more efficiently.</p> <p>learn more about the .cm file</p> <p>automation examples</p> <p> </p>"},{"location":"automation-actions/","title":"Automation actions","text":""},{"location":"automation-actions/#overview","title":"Overview","text":"<p>gitStream executes actions in the order they are listed. If an action result fails, following actions will not be executed.</p> <ul> <li><code>add-comment</code></li> <li><code>add-label</code></li> <li><code>add-reviewers</code></li> <li><code>approve</code></li> <li><code>merge</code></li> <li><code>set-required-approvals</code></li> <li><code>require-reviewers</code></li> <li><code>request-changes</code></li> <li><code>update-check</code></li> </ul> <p>Note</p> <p>Multiple actions can be listed in a single automation. The actions are invoked one by one.</p>"},{"location":"automation-actions/#dynamic-actions-arguments","title":"Dynamic actions arguments","text":"<p>Arguments values a dynamic value is supported using expressions based on Jinja2 syntax, and includes gitStream context variables, for example:</p> <pre><code>automations:\npr_complexity:\nif:\n- true\nrun:\n- action: add-comment@v1\nargs:\ncomment: \"Estimated {{ branch | estimatedReviewTime }} minutes to review\"\n</code></pre>"},{"location":"automation-actions/#reference","title":"Reference","text":""},{"location":"automation-actions/#add-comment","title":"<code>add-comment</code>","text":"<p>This action, once triggered, adds a comment to the PR.</p> Args Type Description <code>comment</code> String Sets the comment, markdown is supported example<pre><code>automations:\nsenior_review:\nif:\n- {{ files | match(term='core/') | some }}\nrun:\n- action: add-comment@v1\nargs:\ncomment: |\nCore service update\n(Updates API)\n</code></pre>"},{"location":"automation-actions/#add-label","title":"<code>add-label</code>","text":"<p>This action, once triggered, adds a label to the PR.</p> <p>This is a manged action, when a PR updates existing labels that was added by gitStream are re-evaluated and those that are not applicable are removed.</p> Args Type Description <code>label</code> String The label text any string can work <code>color</code> String (optional) The color in hexa, for exmaple: <code>'FEFEFE'</code> (you can also add <code>#</code> prefix <code>#FEFEFE</code>) example<pre><code>automations:\nsenior_review:\nif:\n- {{ files | match(term='api/') | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: api-change\n</code></pre>"},{"location":"automation-actions/#add-reviewers","title":"<code>add-reviewers</code>","text":"<p>This action, once triggered, sets a specific reviewer.</p> Args Type Description <code>reviewers</code> [String] Sets reviewers user name example<pre><code>automations:\nsenior_review:\nif:\n- {{ files | match(term='src/ui/') }}\nrun:\n- action: add-reviewers@v1\nargs:\nreviewers: [popeye, olive]\n</code></pre>"},{"location":"automation-actions/#approve","title":"<code>approve</code>","text":"<p>This action, once triggered, approves the PR for merge.</p> <p>This is a manged action, when a PR updates existing approval by gitStream is re-evaluated and removed if no longer applicable.</p> example<pre><code>automations:\nsmall_change:\nif:\n- {{ source.diff.files | isFormattingChange }}\nrun:\n- action: approve@v1\n</code></pre>"},{"location":"automation-actions/#merge","title":"<code>merge</code>","text":"<p>This action, once triggered, approve &amp; merge the PR. It can set to wait for required checks to pass or ignore checks.</p> <p>Syntax: </p> Args Type Description <code>wait_for_all_checks</code> Boolean By default <code>false</code>, so only Required checks can block merge, when <code>true</code> the action won't merrge even if non-Required check fail <code>squash_on_merge</code> Boolean When merging use squash mode example<pre><code>automations:\nsmall_change:\nif:\n- {{ files | allDocs }}\nrun:\n- action: merge@v1\n</code></pre>"},{"location":"automation-actions/#set-required-approvals","title":"<code>set-required-approvals</code>","text":"<p>This action, once triggered, blocks PR merge till the desired reviewers approved the PR. The actions fail the check to prevent the PR for merge.</p> <p>Note</p> <p>You should enable branch protection, so GitHub will prevent merging unless the gitStream action check pass successfully. </p> Args Type Description <code>approvals</code> Integer Sets the number of required reviewer approvals for merge for that PR example<pre><code>automations:\ndouble_review:\nif:\n- {{ files | match(regex=r/agent\\//) | some }}\nrun:\n- action: set-required-approvals@v1\nargs:\napprovals: 2\n</code></pre>"},{"location":"automation-actions/#request-changes","title":"<code>request-changes</code>","text":"<p>This action, once triggered, request changes on the PR. As long as request change is set, gitStream will block the PR merge.</p> <p>This is a manged action, when a PR updates existing change request by gitStream is re-evaluated and removed if no longer applicable.</p> Args Type Description <code>comment</code> [String] The desired request changes comment example<pre><code>automations:\ncatch_deprecated:\nif:\n- {{ source.diff.files | matchDiffLines(regex=r/^[+].*oldFetch\\(/') | some }}\nrun:\n- action: request-changes@v1\nargs:\ncomment: |\nYou have used deprected API `oldFetch`, use `newFetch` instead.\n</code></pre>"},{"location":"automation-actions/#require-reviewers","title":"<code>require-reviewers</code>","text":"<p>This action, once triggered, sets a specific reviewer.</p> Args Type Description <code>reviewers</code> [String] Sets reviewers user name, merge is blocked till approved by any of the listed users example<pre><code>automations:\nsenior_review:\nif:\n- {{ files | match(regex=r/src\\/ui\\//) | some }}\nrun:\n- action: require-reviewers@v1\nargs:\nreviewers: ['popeye', 'olive']\n</code></pre>"},{"location":"automation-actions/#update-check","title":"<code>update-check</code>","text":"<p>Used to workaround unnecessary checks, this action, update the defined check with the defined status if all conditions pass.</p> Args Type Description <code>check_name</code> String The name of the check <code>status</code> String The status of the check <code>conclusion</code> String The conclusion of the check example<pre><code>automations:\nsenior_review:\nif:\n- {{ files | match(regex=r/.*\\.png$|.*\\.jpg$|.*\\.svg$|.*\\.css$/) | every }}\nrun:\n- action : update-check@v1\nargs:\ncheck_name: cypress-e2e\nstatus: completed\nconclusion: success\n</code></pre>"},{"location":"context-variables/","title":"Context variables","text":""},{"location":"context-variables/#overview","title":"Overview","text":""},{"location":"context-variables/#context","title":"Context","text":"<p>gitStream includes a collection of variables called contexts. </p> <ul> <li><code>branch</code></li> <li><code>files</code></li> <li><code>source</code></li> <li><code>repo</code></li> </ul>"},{"location":"context-variables/#structures","title":"Structures","text":"<p>The following structures are used in the context objects:</p> <ul> <li><code>FileMetadata</code></li> <li><code>FileDiff</code></li> <li><code>Contributor</code></li> </ul> Example of a context object <p>Example of a context object for a PR that changed few lines in a <code>README.md</code> file:</p> <pre><code>{\n\"branch\": {\n\"name\": \"new-feature-branch\",\n\"base\": \"main\",\n\"diff\": {\n\"size\": 50,\n\"files_metadata\": [\n{\n\"original_file\": \"README.md\",\n\"new_file\": \"README.md\",\n\"deletions\": 0,\n\"additions\": 2\n}\n]\n},\n\"num_of_commits\": 1\n},\n\"source\": {\n\"diff\": {\n\"files\": [\n{\n\"original_file\": \"README.md\",\n\"new_file\": \"README.md\",\n\"diff\": \"@@ -10,3 +10,5 @@ This project \\n+\\n+## Intro\",\n\"original_content\": \"This project \\n\",\n\"new_content\": \"This project \\n\\n## Intro\"\n}\n]\n}\n},\n\"repo\": {\n\"contributors\": {\n\"popeye\": \"46\",\n\"olive\": \"6\"\n}\n},\n\"files\": [\n\"README.md\"\n]\n}\n</code></pre>"},{"location":"context-variables/#reference","title":"Reference","text":""},{"location":"context-variables/#branch","title":"<code>branch</code>","text":"<p>The <code>branch</code> context contains info regarding the branch changes compared to the base branch. </p> <p>Note</p> <p>compared to the <code>source</code> context does not include actual source code.</p> Values Type Description <code>branch</code> Map Includes the info related to the current branch <code>branch.author</code> String The branch author (the user that did first commit in the branch). The formatted like author in <code>git-log</code>, e.g. <code>Popeye &lt;popeye@acme.com&gt;</code> <code>branch.base</code> String The main branch, <code>main</code> <code>branch.num_of_commits</code> Integer The number of commits in the branch <code>branch.diff.size</code> Integer The sum of line changed: additions, edits and deletions <code>branch.diff.files_metadata</code> [<code>FileMetadata</code>] List of changed files including their relative path <code>branch.name</code> String The current branch, <code>feature-123-branch</code> <p>The branch context doesn't include any source code, but only related metadata.</p>"},{"location":"context-variables/#filemetadata-structure","title":"<code>FileMetadata</code> structure","text":"<p>The <code>branch.diff.files_metadata</code> mapping includes a list of <code>FileMetadata</code>:</p> Values Type Description <code>additions</code> Integer The number of lines edited or added to the file <code>deletions</code> Integer The number of lines removed from the file <code>file</code> String The name of the file before the changes, including its path"},{"location":"context-variables/#files","title":"<code>files</code>","text":"<p>The <code>files</code> context includes the list of changed files in the branch compared to the main branch.</p> Values Type Description <code>files</code> [String] List of all changed files with their full path"},{"location":"context-variables/#source","title":"<code>source</code>","text":"<p>The <code>source</code> context includes a list of <code>FileDiff</code> objects that can be used to get insights based on code changes. The changes compared to the latest main branch. </p> Values Type Description <code>source.diff.files</code> [<code>FileDiff</code>] List of changed files with their code changes <p>The source context include all code changes, it is not safe to share it with unknown services.</p>"},{"location":"context-variables/#filediff-structure","title":"<code>FileDiff</code> structure","text":"<p>The <code>source.diff.files</code> mapping includes a list of <code>FileDiff</code>:</p> Values Type Description <code>diff</code> String The content in diff format <code>+</code> for additions, <code>-</code> for deletions <code>new_content</code> String The new content in this branch <code>new_file</code> String The name of the file after the changes, including its path <code>original_content</code> String The content as is in the <code>main</code> branch <code>original_file</code> String The name of the file before the changes, including its path"},{"location":"context-variables/#repo","title":"<code>repo</code>","text":"<p>The <code>repo</code> context includes metadata related to the repo.</p> Values Type Description <code>repo</code> Map Includes the info related to the current repo <code>repo.contributors</code> [<code>Contributor</code>] List of changed files including their relative path"},{"location":"context-variables/#contributor-structure","title":"<code>Contributor</code> structure","text":"<p>The <code>repo.contributors</code> mapping includes a list of <code>Contributor</code>:</p> Values Type Description <code>name</code> Number Number of commits"},{"location":"custom-filters/","title":"Custom filters","text":"<p>Attention</p> <p> Coming soon</p> <p>Custom filters are implemented in JavaScript.</p> <p>You can add custom filters by editing the <code>.cm/filters.js</code> file in your repo.</p> <pre><code>.\n\u251c\u2500 .cm/\n\u2502  \u2514\u2500 gitstream.cm\n\u2502  \u2514\u2500 filters.js \n</code></pre>"},{"location":"custom-filters/#adding-filters","title":"Adding filters","text":"<p>Filters can have input arguments and return a result which can be any valid JavaScript type.</p> <p>An example for a <code>.cm/filters.js</code>:</p> <pre><code>export default {\n// The includes() method determines whether an array includes a \n// certain value among its entries, returning true or false.\nmyIncludes: (list, term) =&gt; {\nreturn list.includes(term);\n},\n// Determine if a number is even or odd\nisOdd: (n) =&gt; {\nreturn parseInt(n) % 2 == 0;\n}\n}\n</code></pre> <p>Once filters are added it can be used in the <code>.cm</code> files, for example using <code>isOdd</code> filter looks like this:</p> <pre><code>{{ branch.diff.size | isOdd }}\n</code></pre>"},{"location":"custom-filters/#using-npm-packages","title":"Using npm packages","text":"<p>The file is loaded by a node.js runtime, the following packages are pre installed and can be imported and used:</p> <ul> <li><code>child_process</code></li> </ul>"},{"location":"custom-filters/#using-external-tools-results","title":"Using external tools results","text":"<p>Tip: cache result to local file system and reuse in CI/CD</p> <pre><code>const { exec } = require('child_process');\nexec('npm run test | wc -l', (err, stdout, stderr) =&gt; {\nif (err) {\n// node couldn't execute the command\nreturn;\n}\n// the *entire* stdout and stderr (buffered)\nconsole.log(`stdout: ${stdout}`);\nconsole.log(`stderr: ${stderr}`);\nreturn 123;\n});\n</code></pre> <p>For example:</p> <pre><code># access coverage results\ncoverage:\nis:\n# npm run test -&gt; /file/here \nenough: {{ source | my_coverage &gt; 80 }} # 2 user's filter \n</code></pre>"},{"location":"editing-cm-file/","title":"Overview gitstream.cm","text":"<p>This document is a reference for the gitStream 1.x, used in <code>.cm/gitstream.cm</code> file. You can edit the <code>.cm/gitstream.cm</code> and add your own checks and automations. Check out the examples </p>"},{"location":"editing-cm-file/#context-variables","title":"Context variables","text":"<p>gitStream includes a collection of variables called contexts. These variable has all the inputs you need to code your automation, including files names and paths, code that was changed or who did the change. See more here.</p>"},{"location":"editing-cm-file/#filter-functions","title":"Filter functions","text":"<p>Filter funstions are essentially callable functions that can be applied to variables. They are called with a pipe operator <code>|</code> and can take arguments inside parentheses <code>( )</code>. The logic expressions are based on Jinja2 syntax, supported by Nunjucks library.</p> <p>See more about the Nunjucks built-in filters here, and about gitStream built-in filters here.</p>"},{"location":"editing-cm-file/#automation-actions","title":"Automation actions","text":"<p>Specify the desired automations that are triggered when all conditions are met, read more here.</p> <p>The conditions are evaluated on new Pull Requests or changes to the Pull Request. </p> <p>PRs that are marked as Draft are ignored by default, you can change that, see <code>config</code> .</p>"},{"location":"editing-cm-file/#schema","title":"Schema","text":"<p>The following sections are used in <code>.cm</code> file to describe the desired automations:</p> <ul> <li><code>manifest</code></li> <li><code>config</code></li> <li><code>automations</code></li> </ul>"},{"location":"editing-cm-file/#manifest","title":"<code>manifest</code>","text":"<p>The first section in a <code>gitstream.cm</code> file is the <code>manifest</code>.</p> <pre><code>manifest: version: 1.0\n</code></pre> <p>The only field required is <code>version</code>.</p> Key Required Type Description <code>manifest</code> Y Map The manifest section root <code>manifest.version</code> Y String Specify the <code>.cm</code> spec version: 0.1, 1.0 <p>The manifest version field is used to parse the <code>.cm</code> file, in the future if breaking changes are introduced to the parser then older automation will be still supported.</p>"},{"location":"editing-cm-file/#config","title":"<code>config</code>","text":"<p>The <code>config</code> section is optional in <code>gitstream.cm</code> file and is used to specify configuration for the way gitStream works.</p> Key Required Type Default Description <code>config</code> N Map - The config section root <code>config.ignore_files</code> N [String] - Specifies files that will not be included in the context variables <p><code>config.ignore_files</code> supports glob pattern matching that contains list of files to ignore, for example:</p> <pre><code>config:\nignore_files:\n- 'yarn.lock'\n- 'package-lock.json'\n- 'openapi.json'\n- 'ui/src/**/*Model.d.ts'\n</code></pre>"},{"location":"editing-cm-file/#automations","title":"<code>automations</code>","text":"<p>The <code>automations</code> section defines the automations and their conditions. </p> <pre><code>automations:\nmark_small_pr:\nif:\n- {{ checks.size.is.xsmall }}\nrun:\n- action: add-label@v1\nargs:\nlabel: xsmall\n</code></pre> <p>Each automation includes its name, and few fields: <code>if</code> and <code>run</code>.</p> Key Required Type Description <code>automations</code> Y Map The automations section root <code>automations.NAME</code> Y Map User defined name of the automation, can be any string <code>automations.NAME.if</code> Y Map List of conditions <code>automations.NAME.run</code> Y Map The automation to run if all conditions are met <p>The <code>if</code> field includes the list of conditions. The conditions are checked when a pull request  is opened or changed, if all the conditions pass, the automation is executed.</p> <p>The <code>run</code> field includes the automation to execute. It includes the following fields:</p> Key Required Type Description <code>action</code> Y String The action pointer <code>engine</code> N String The action engine, default is <code>gitstream</code> <code>args</code> N List The action inputs list <p>For <code>gitstream</code> engine, the action is specified by: <code>name@version</code></p> <p>gitStream supported actions, see actions.</p>"},{"location":"editing-cm-file/#reusing-checks","title":"Reusing checks","text":"<p>You can define an accessory section, e.g. <code>checks</code>, that defines common conditions, and resue.  </p> <pre><code>size:\nis:\nsmall: {{ branch.diff.size &lt; 20 }}\nmedium: {{ branch.diff.size &gt;= 20 and branch.diff.size &lt; 100 }}\nlarge: {{ branch.diff.size &gt;= 100 }}\nautomations:\napprove_small:\nif:\n- {{ size.is.small }}\nrun:\n- action: approve@v1\nmark_small_medium:\nif:\n- {{ size.is.small or size.is.medium }}\nrun:\n- action: add-label@v1\nargs:\nlabel: 'good-size'\n</code></pre>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#label-prs-by-their-complexity","title":"Label PRs by their complexity","text":"<p>Automatically add a label to PRs with their Estimated Time to Review and a matching color.</p> .cm/gitstream.cm<pre><code>automations:\nestimated_time_to_review:\nif:\n- true\nrun:\n- action : add-label@v1\nargs:\nlabel: \"{{ calc.etr }} min review\"\ncolor: {{ 'E94637' if (calc.etr &gt;= 20) else ('FBBD10' if (calc.etr &gt;= 5) else '36A853') }}\n# To simplify the automation, this calculation is placed under a unique YAML key.\n# The result is is assigned to `calc.etr` which is used in the automation above.\n# You can add as many keys as you like.\ncalc:\netr: {{ branch | estimatedReviewTime }}\n</code></pre>"},{"location":"examples/#approve-safe-changes","title":"Approve safe changes","text":"<p>PRs that include only documentations changes are verified and approved by gitStream. In the example below, marked in yellow, the <code>files</code> context is checked by <code>allDocs</code> filter that verifies there are only document files. PRs that pass the check are approved by gitStream.</p> .cm/gitstream.cm<pre><code>automations:\nsafe_changes:\nif:\n- {{ is.formatting or is.docs or is.tests }}\nrun: - action: add-labels@v1\nargs:\nlabels: ['safe-changes']\n- action: approve@v1\n# To simplify the automation, this calculation is placed under a unique YAML key.\n# The result is is assigned to `is.formatting`, `is.docs` and `is.tests` which is \n# used in the automation above. You can add as many keys as you like.\nis:\nformatting: {{ source.diff.files | isFormattingChange }}\ndocs: {{ files | allDocs }}\ntests: {{ files | allTests }}\n</code></pre>"},{"location":"examples/#more-approvals-for-complex-changes","title":"More approvals for complex changes","text":"<p>Automatically require 2 reviewers for PRs that have more than 100 lines of code changed under the <code>src</code> directory.</p> .cm/gitstream.cm<pre><code>automations:\ndouble_review:\nif:\n- {{ branch | estimatedReviewTime &gt;= 30 }}\n- {{ files | length &gt;= 10 }}\n- {{ files | match(regex=r/src\\//') | some }}\nrun:\n- action: set-required-approvals@v1\nargs:\nreviewers: 2\n</code></pre>"},{"location":"examples/#validate-formatting-changes-only-for-javascripttypescript","title":"Validate formatting changes only for JavaScript/TypeScript","text":"<p>For PRs that include only code format change, approve merge automatically. The automation includes 2 actions that both are executed, one after another, when all conditions pass.</p> .cm/gitstream.cm<pre><code>automations:\nallow_formatting:\nif:\n- {{ files | extensions | match(list=['js', 'ts']) | every }}\n- {{ source.diff.files | isFormattingChange }}\nrun:\n- action: approve@v1\n- action: add-label@v1\nargs:\nlabel: code-formatting\n</code></pre> <p>Note</p> <p>Multiple actions can be listed in a single automation. The actions are invoked one by one.</p> <p>Multiple conditions can be listed for a single automation. All listed conditions must pass to trigger the actions.</p>"},{"location":"examples/#request-changes-on-deprecated-apis","title":"Request changes on deprecated APIs","text":"<p>For example, assume we have an old API <code>callElvis</code> we want to switch from to a new API <code>callGaga</code>, gitStream can review and trigger a change request automatically when the PR includes use of the deprecated API.</p> .cm/gitstream.cm<pre><code>automations:\n{% for item in deprecated %}\n# Automation names should be unique, therefore the iteration number postfix\ncatch_deprecated_components_{{ loop.index }}:\nif:\n- {{ source.diff.files | matchDiffLines(regex=item.regex) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: 'deprecated-component'\ncolor: '#FF0000'\n- action: request-changes@v1\nargs:\ncomment: |\n`{{ item.old }}` component is deprecated, use `{{ item.new }}` instead\n{% endfor %}\n# This list includes the deprecated items\ndeprecated:\n- regex: r/callElvis/\nold: Elvis\nnew: Gaga\n- regex: r/callOldAPI/\nold: callOldAPI\nnew: callBetterAPI\n</code></pre> <p></p>"},{"location":"examples/#approve-additions-to-tests","title":"Approve additions to tests","text":"<p>You can use map to check that a PR was about adding more tests.</p> .cm/gitstream.cm<pre><code>automations:\ntests_safe_changes:\nif:\n# Given the PR files changes, check that only tests were changed. The allTests filter checks for \n# the substring `test` or `spec` in the file path or file name.\n- {{ files | allTests }}\n# Checking `changes.ratio` which is calculated below\n- {{ changes.ratio &gt; 0.8 }}\nrun: - action: add-label@v1\nargs:\nlabel: 'tests-changes'\n- action: add-comment@v1\nargs:\ncomment: |\nPR added tests (ratio: {{ changes.ratio }})\n# - action: approve@v1\n# You can add more sections to the .cm file to place more logic, and use it in your automations\n# The following logic `ratio` result is used in the automation above by checking `changes.ratio`\nchanges:\n# Sum all the line added/edited in the PR\nadditions: {{ branch.diff.files_metadata | map(attr='additions') | sum }}\n# Sum all the line removed in the PR\ndeletions: {{ branch.diff.files_metadata | map(attr='deletions') | sum }}\n# Calculate the ratio to check if it is about new code\nratio: {{ changes.additions / (changes.additions + changes.deletions) }}\n</code></pre> <p>As a result, if you add test cases to your repo, gitStream can automatically check that and approve the PR automatically.</p> <p></p>"},{"location":"examples/#approve-changes-to-prints","title":"Approve changes to prints","text":"<p>When you just want to change the way to print to screen, you can get it approved as long as you didn't change anything else.</p> .cm/gitstream.cm<pre><code>automations:\n# for JavaScript\nprints_changes_in_js:\nif: - {{ files | match(regex=r/\\.js$|\\.ts$/) | every }}\n- {{ files | length == 1 }}\n- {{ source.diff.files | matchDiffLines(regex=r/^[+-].*console\\.log/, ignoreWhiteSpaces=true) | every }}\nrun: - action: add-label@v1\nargs:\nlabel: 'prints-changes'\n- action: approve@v1\n# for Python\nprints_changes_in_py:\nif: - {{ files | match(regex=r/\\.py$/) | every }}\n- {{ files | length == 1 }}\n- {{ source.diff.files | matchDiffLines(regex=r/^[+-].*logger\\.(trace|debug|info|warn|error)/, ignoreWhiteSpaces=true) | every }}\nrun: - action: add-label@v1\nargs:\nlabel: 'prints-changes'\n- action: approve@v1\n</code></pre>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#what-permissions-needed","title":"What permissions needed?","text":"<p>In your repo permissions make sure GitHub actions are permitted:</p> <p>Go to Repo's settings &gt; Actions &gt; General &gt; Actions permissions</p> <p>Choose which repositories are permitted to use GitHub Actions.</p> <p>[x] Allow all actions and reusable workflows</p>"},{"location":"faq/#does-gitstream-services-have-access-to-my-code","title":"Does gitStream services have access to my code?","text":"<p>Like any other CI/CD automation, the source code is being scanned in the repo and is not shared with any external services. Only metadata that relates and affects the workflow is shared to allow rule based automation on the repo.</p>"},{"location":"faq/#why-does-gitstream-require-permission-to-write-code","title":"Why does gitStream require permission to write code?","text":"<p>In order to support automations that either Approve or Merge PRs, GitHub API requries code write scope.</p>"},{"location":"faq/#what-repos-are-supported","title":"What repos are supported?","text":"<p>Any repo in GitHub is supported. More Git providers are planned soon.</p>"},{"location":"faq/#do-i-need-vs-code-to-use-gitstream","title":"Do I need VS Code to use gitStream?","text":"<p>No. gitStream is a CM automation system, nevertheless, developers can benefit from having the VS Code  extension as it presents in the editor what rules can be used to simplify their workflow.</p>"},{"location":"faq/#custom-filter-functions","title":"Custom filter functions","text":"<p>Coming soon.</p>"},{"location":"filter-functions/","title":"Filter functions","text":"<p>Filters can change the look and format of the source data, or even generate new data derived from the input values. What's important is that the original data is replaced by the result of transformations, and that's what ends up in rendered templates.</p>"},{"location":"filter-functions/#overview","title":"Overview","text":"<p>The following functions are supported in addition to the built-in functions provided by Nunjucks.</p>"},{"location":"filter-functions/#low-level-functions","title":"Low level functions","text":"Function Input Args Output <code>every</code>Checks whether all element in the list are <code>true</code> [Bool] - Bool <code>filter</code>Reduce list of items into a list of same items that match the specified term [String][Object] <code>regex</code>, <code>term</code>, <code>list</code>, <code>attr</code> [String][Object] <code>includes</code>Check if substring match String <code>regex</code>, <code>term</code>, <code>list</code> Bool <code>map</code>Maps each object in a list into their specified attribute value [Object] <code>attr</code> [Object] <code>match</code>Maps list of items into a list of booleans that match the specified term [String][Object] <code>regex</code>, <code>term</code>, <code>list</code> <code>attr</code> [Bool] <code>nope</code>Checks whether all element in the list are <code>false</code> [Bool] - Bool <code>reject</code>Inverse of <code>filter</code>, the result list contains non-matching items [String][Object] <code>regex</code>, <code>term</code>, <code>list</code>, <code>attr</code> [String][Object] <code>some</code>Checks whether at least one element in the list is <code>true</code> [Bool] - Bool"},{"location":"filter-functions/#high-level-functions","title":"High level functions","text":"Function Input Args Output <code>allDocs</code>Checks the list includes only documents files - Bool <code>allImages</code>Checks the list includes only images files - Bool <code>allTests</code>Checks the list includes only tests files - Bool <code>estimatedReviewTime</code>Estimated review time in minutes branch - Integer <code>extensions</code>Lists all the unique file extensions [String] - [String] <code>isFormattingChange</code>Checks that only formatting changed [<code>FileDiff</code> ] - Bool <code>matchDiffLines</code>Match every line in diff [<code>FileDiff</code> ] <code>regex</code>, <code>ignoreWhiteSpaces</code> [Bool]"},{"location":"filter-functions/#named-arguments","title":"Named arguments","text":"<p>Some functions supports named arguments, many of these repeat in different functions.</p> <p><code>term</code> - a single string, used as substring to match with the matched item.</p> <p><code>list</code> - a list of strings, trying to match any of the listed substrings with the matched item.</p> <p><code>regex</code> - a single string, used as regular expression to with the matched item. A regular expression can be created just like JavaScript, but needs to be prefixed with r, for example <code>r/^foo.*/g</code>, for more info see Nunjucks. </p> <p><code>globs</code> - a key to an element in the <code>.cm</code> that holds a list of strings, used as glob pattern test on the matched item. For more info see Wikipedia.</p> <p><code>attr</code> - a key in the element to use when doing the requested operation.</p> <p>For example, the following expressions provide an identical result:</p> <pre><code>- {{ 'something' | includes(regex=r/^some.*/) }}\n- {{ 'something' | includes(term='some') }}\n- {{ 'something' | includes(list=['some']) }}\n</code></pre>"},{"location":"filter-functions/#reference","title":"Reference","text":""},{"location":"filter-functions/#every","title":"<code>every</code>","text":"<p>Checks whether all element in the list are\u00a0<code>true</code>. In case the list of elements is empty it will return <code>false</code>.</p> Argument Usage Type Description - Input [Bool] List of booleans - Output Bool Returns <code>true</code> when all list items are <code>true</code> <p>For example, check that all changes are in either 'src' or 'dest' directories:</p> <pre><code>{{ files | match(list=['src', 'dest']) | every }}\n</code></pre>"},{"location":"filter-functions/#filter","title":"<code>filter</code>","text":"<p>Creates a shallow copy of a portion of a given list, filtered down to just the elements that match the given term. You can use either single term, regex or a list of terms to match with.</p> Argument Usage Type Description - Input [String][Object] The list of strings to match, or list of objects if <code>attr</code> is used <code>term</code><code>regex</code><code>list</code> Input (either) StringString[String] Search term to match with the input items <code>attr</code> Input  (optional) String match a named attribute in the input object - Output [String][Object] The list with only the matching items <p>For example, check if all changes to JavaScript files are in tests directory:</p> <pre><code>{{ files | filter(regex=r/\\.js$/) | match(regex=r/tests\\/) | every }}\n</code></pre> <p>For example, check if all changes to JavaScript files are formatting:</p> <pre><code>{{ source.diff.files | filter(attr='new_file', regex=r/\\.js$/) | isFormattingChange }}\n</code></pre>"},{"location":"filter-functions/#includes","title":"<code>includes</code>","text":"<p>Determines whether a string includes a certain substring. You can use either single term, regex or a list of terms to match with.</p> Argument Usage Type Description - Input String The list of strings to match <code>term</code><code>regex</code><code>list</code> Input (either) StringString[String] Substring term to match - Output Bool <code>true</code> if search terms matches <p>Check string matches either of the terms:</p> <pre><code>{{ 'something' | includes(list=['any', 'thing']) }}\n</code></pre>"},{"location":"filter-functions/#map","title":"<code>map</code>","text":"<p>Creates a new list populated with the values of the selected attribute of every element in the input list. </p> Argument Usage Type Description - Input [Object] The list of objects to map, see context for valid inputs <code>attr</code> Input String Object attribute to select - Output [Object] List of the selected object attributes <p>For example, the <code>source.diff.files</code> context holds a list of <code>FileDiff</code> , each has <code>new_file</code> attribute. You can create a list of all the new file names by mapping to the <code>new_file</code> attribute and then check if there are changes to any <code>handler.js</code> file:</p> <pre><code>{{ source.diff.files | map(attr='new_file') | match(term='handler.js') | some }}\n</code></pre>"},{"location":"filter-functions/#match","title":"<code>match</code>","text":"<p>Return <code>true</code> for each element in the list that match the search term.</p> Argument Usage Type Description - Input [String][Object] The list of strings or if <code>attr</code> used the list of objects <code>term</code><code>regex</code><code>list</code> Input (either) StringString[String] Search term to match <code>attr</code> Input String match a named attribute in the input object - Output [Bool] <code>true</code> for every matching item <p>For example, to check if all code changes are in the <code>tests</code> directory:</p> <pre><code>{{ files | match(regex=r/tests\\//) | every }}\n</code></pre> <p>For example, to check if there are code changes with specific function call:</p> <pre><code>{{ source.diff.files | match(attr='diff', term='myFunction') | some }}\n</code></pre>"},{"location":"filter-functions/#nope","title":"<code>nope</code>","text":"<p>The inverse of <code>every</code>, checks whether all element in the list are\u00a0<code>false</code>. In case the list of elements is empty it will return <code>false</code>.</p> Argument Usage Type Description - Input [Bool] List of booleans - Output Bool Returns <code>true</code> when all list items are <code>false</code> <p>For example, check that no changes in either 'src' or 'dest' directories:</p> <pre><code>{{ files | match(list=['src', 'dest']) | nope }}\n</code></pre>"},{"location":"filter-functions/#reject","title":"<code>reject</code>","text":"<p>Creates a shallow copy of a portion of a given list, filtered down to just the elements that does not match the given term. You can use either single term, regex or a list of terms to match with.</p> Argument Usage Type Description - Input [String][Object] The list of strings to match, or list of objects if <code>attr</code> is used <code>term</code><code>regex</code><code>list</code> Input (either) StringString[String] Search term to match with the input items <code>attr</code> Input  (optional) String match a named attribute in the input object - Output [String][Object] The list with only the non-matching items <p>For example, check if all changes but JavaScript files are in tests directory:</p> <pre><code>{{ files | reject(regex=r/\\.js$/) | match(regex=r/tests\\//') | every }}\n</code></pre> <p>For example, check if all changes except for <code>config.json</code> files are formatting:</p> <pre><code>{{ source.diff.files | reject(attr='new_file', regex=r/config\\.json$/) | isFormattingChange }}\n</code></pre>"},{"location":"filter-functions/#some","title":"<code>some</code>","text":"<p>Checks whether any element in the list is\u00a0<code>true</code>. In case the list of elements is empty it will return <code>false</code>.</p> Argument Usage Type Description - Input [Bool] List of booleans - Output Bool Returns <code>true</code> when any of the items is <code>true</code> <pre><code>{{ files | match(list=['src', 'dest']) | some }}\n</code></pre>"},{"location":"filter-functions/#alldocs","title":"<code>allDocs</code>","text":"<p>Return <code>true</code> if the input list includes only documents based on file extensions.</p> Argument Usage Type Description - Input <code>files</code> The list of changed files with their path - Output Bool <code>true</code> if all file extensions are of docs <p>Doc files extensions are: <code>md</code>, <code>mkdown</code>, <code>txt</code>, <code>rst</code>.</p> <pre><code>{{ files | allDocs }}\n</code></pre>"},{"location":"filter-functions/#allimages","title":"<code>allImages</code>","text":"<p>Return <code>true</code> if the input list includes only images based on file extensions.</p> Argument Usage Type Description - Input <code>files</code> The list of changed files with their path - Output Bool <code>true</code> if all file extensions are of images <p>Image file extensions are: <code>svg</code>, <code>png</code>, <code>gif</code>.</p> <pre><code>{{ files | allImages }}\n</code></pre>"},{"location":"filter-functions/#alltests","title":"<code>allTests</code>","text":"<p>Return <code>true</code> if the input list includes only tests based on file's path and name.</p> Argument Usage Type Description - Input <code>files</code> The list of changed files with their path - Output Bool <code>true</code> if all file tests based on name and path <p>Test files must include the substring <code>test</code> or <code>spec</code> in its name or path.</p> <pre><code>{{ files | allTests }}\n</code></pre>"},{"location":"filter-functions/#estimatedreviewtime","title":"<code>estimatedReviewTime</code>","text":"<p>Returns the estimated review time in minutes based on statistical model. The model uses the PR size and type of file changed to produce the estimation.</p> Argument Usage Type Description - Input <code>branch</code> Branch meta data - Output Integer the estimated time for review in minutes <pre><code>{{ branch | estimatedReviewTime }}\n</code></pre>"},{"location":"filter-functions/#extensions","title":"<code>extensions</code>","text":"<p>Expects <code>files</code> and provide a list of all unique file extensions.</p> Argument Usage Type Description - Input <code>files</code> The list of changed files with their path - Output [String] List of all unique file extensions <p>For example, check that only one file type was changed:</p> <pre><code>{{ files | extensions | length == 1 }}\n</code></pre>"},{"location":"filter-functions/#isformattingchange","title":"<code>isFormattingChange</code>","text":"<p>Return <code>true</code> if all file diffs are validated as formatting changes.</p> <p>Support source code languages: JavaScript, TypeScript, JSON, YAML and HTML.</p> <p>If changes in other formats detected, the filter will return <code>false</code>.</p> Argument Usage Type Description - Input <code>source.diff.files</code> List of file diffs - Output Bool <code>true</code> if the all code changes are non functional <pre><code>{{ source.diff.files | isFormattingChange }}\n</code></pre>"},{"location":"filter-functions/#matchdifflines","title":"<code>matchDiffLines</code>","text":"<p>Checks diff for matching lines.</p> Argument Usage Type Description - Input [Object] The list of objects <code>regex</code> Input String Regex term to match with the input items, use <code>\\\\</code> for <code>\\</code> <code>ignoreWhiteSpaces</code> Input Bool match a named attribute in the input object - Output [Bool] <code>true</code> for every matching object <p>For example, to check if all the changes are of adding prints and ignore white spaces:</p> <pre><code>{{ source.diff.files | matchDiffLines(regex=r/^\\+.*console\\.log/, ignoreWhiteSpaces=true) | every }}\n</code></pre>"},{"location":"github-app-setup/","title":"GitHub app installation","text":"<p>To start using gitStream with GitHub source code hosting, a GitHub app should be installed. The installation start with installing the app from the GitHub Apps marketplace.</p> <p>gitStream can be installed for one repo, specific repos, or all repos in your organization. </p> <p>Note: we recommend installing for all repositories, as it will also cover new repos you add in the future. You can change this setting at any time if you change your mind.</p> <p>The permissions are: </p> Permissions Reason Write access to dedicated gitStream app files Used to set the gitStream workflow files Write access to code To allow gitStream to approve PRs once all conditions are met Read access to administration, issues, and metadata To read the code on monitored repositories Read and write access to actions, checks, pull requests, and workflows Trigger workflows, create and update pull requests and their checks, and modify workflow files User email Used to identify user <p>Once installation completes, the following files are added to each of the selected repos under their root directory.</p> <pre><code>.\n\u251c\u2500 .cm/\n\u2502  \u2514\u2500 gitstream.cm\n\u251c\u2500 .github/\n\u2502  \u2514\u2500 workflows/\n\u2502     \u2514\u2500 gitstream.yml\n</code></pre> File and path Customizable Reason .cm/gitstream.cm Y Used to specify gitStream automations, you can edit this file .github/workflows/gitstream.yml N Used by gitStream to execute automation in your repo so source code doesn't get to outside services"},{"location":"github-app-setup/#set-github-repo-settings","title":"Set GitHub repo settings","text":"<p>Attention</p> <p>To get the full potential using gitStream, you need to set it as a required check.</p> <p>To make sure gitStream can block PRs from merging under certain conditions, you should set the following:</p> <ol> <li>Go to repo <code>settings</code></li> <li>On the left pane select <code>Code and automation</code> &gt; <code>Branches</code> </li> <li>Set <code>Branch protection rules</code> for your desired branch </li> <li>Enable <code>Require status checks to pass before merging</code></li> <li>Search for <code>status checks in the last week for this repository</code></li> <li>Select <code>gitStream.cm</code> as required check</li> </ol>"},{"location":"github-installation/","title":"Welcome to gitStream","text":""},{"location":"github-installation/#insert-workflow-automation-files-to-your-repo","title":"Insert workflow automation files to your repo","text":"<p>To start using gitStream, install it and add the following files in your repo default branch.</p> <ol> <li>Make sure you have installed gitStream app from GitHub marketplace, then</li> </ol> <p>Add the following 2 files into your repo default branch  (usually <code>master</code> or <code>main</code>):</p> <ol> <li><code>.cm/gitstream.cm</code></li> <li><code>.github/workflows/gitstream.yml</code></li> </ol> <p>Copy-paste from here:</p> <code>.cm/gitstream.cm</code> <code>.github/workflows/gitstream.yml</code> <pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\n# The `automations` section includes a list of automation that applies \n# to the repository in which gitStream is installed. Each automation has an \n# `if` key with a list of the necessary assertions, as well as a `run` key with a\n# list of all actions. All the listed assertions need to pass in order \n# for the following actions to be executed (there is AND relation between conditions).\n# Each automation under the `automations` section is independent of the others. \n# Every time a PR is opened or changed, the automation's conditions are evaluated (the `if`). \n# The actions under `run` are executed one by one if all the conditions pass. \n# Conditions consists of an expression, which are wrapped with double curly braces, and \n# includes a context variable like `files` and filter functions like `length`. Filters \n# functions are essentially functions that can be applied to context variables. They are \n# called with a pipe operator (|) and can take arguments. Read more on https://docs.gitstream.cm\nautomations:\n# This is the name of the review automation. You can use whatever name, a meaningful name \n# will help to identify it in the future. Each automation name in this file should be unique.\nestimated_time_to_review:\nif:\n- true\nrun:\n- action : add-label@v1\nargs:\nlabel: \"{{ calc.etr }} min review\"\ncolor: {{ 'E94637' if (calc.etr &gt;= 20) else ('FBBD10' if (calc.etr &gt;= 5) else '36A853') }}\nsafe_changes:\n# The `if` key has a list of conditions, each condition is specified as a Jinja expression\n# in a double curly braces. Expressions are evaluated by gitStream on a PR when triggered.\nif:\n# Given the PR code changes, check that only formatting changes were made \n- {{ is.formatting or is.docs or is.tests }}\n# `run` key has a list of actions, which are executed one by one whenever the automation \n# conditions are met. \nrun: # When the changes are validated as formatting only, you can help to speed up the review \n# by adding a label that marks it accordingly.\n- action: add-label@v1\nargs:\nlabel: 'safe-changes'\n# You can uncomment the following action to get gitStream can even automatically approve \n# such PRs to save reviewers time for such changes.\n# - action: approve@v1\ncalc:\netr: {{ branch | estimatedReviewTime }}\nis:\nformatting: {{ source.diff.files | isFormattingChange }}\ndocs: {{ files | allDocs }}\ntests: {{ files | allTests }}\n</code></pre> <pre><code># Code generated by gitStream GitHub app - DO NOT EDIT\nname: gitStream workflow automation\non:\nworkflow_dispatch:\ninputs:\nclient_payload:\ndescription: The Client payload\nrequired: true\nfull_repository:\ndescription: the repository name include the owner in `owner/repo_name` format\nrequired: true\nhead_ref:\ndescription: the head sha\nrequired: true\nbase_ref:\ndescription: the base ref required: true\ninstallation_id:\ndescription: the installation id\nrequired: false\nresolver_url:\ndescription: the resolver url to pass results to\nrequired: true\nresolver_token:\ndescription: Optional resolver token for resolver service\nrequired: false\ndefault: ''\njobs:\ngitStream:\ntimeout-minutes: 5\nruns-on: ubuntu-latest\nname: gitStream workflow automation\nsteps:\n- name: Evaluate Rules\nuses: linear-b/gitstream-github-action@v1\nid: rules-engine\nwith:\nfull_repository: ${{ github.event.inputs.full_repository }}\nhead_ref: ${{ github.event.inputs.head_ref }}\nbase_ref: ${{ github.event.inputs.base_ref }}\nclient_payload: ${{ github.event.inputs.client_payload }}\ninstallation_id: ${{ github.event.inputs.installation_id }}\nresolver_url: ${{ github.event.inputs.resolver_url }}\nresolver_token: ${{ github.event.inputs.resolver_token }}\n</code></pre>"},{"location":"how-it-works/","title":"How it works","text":"<p>Every time a dev opens a new Pull Request or changes a Pull Request, gitStream is triggered. Next, the <code>.cm</code> file is used to determine which automatic actions are invoked based on their conditions. The resulting actions use GitHub API to achieve the desired outcome.</p> <p>Next steps are common practice of changing code in repo:</p> <ol> <li>Create a feature branch </li> <li>Commit changes  </li> <li>Push branch to remote repo </li> <li>Open Pull Request </li> </ol> <pre><code>gitGraph\n   commit id: \"A\"\n   commit id: \"B\"\n   branch feature\n   commit id: \"C\"\n   commit id: \"D\"\n   commit id: \"E\"\n   checkout main\n   commit id: \"F\"\n   commit id: \"G\"</code></pre> <p>When a new PR is opened, several actors are running:</p> <ol> <li>GitHub API</li> <li>gitStream app which you have installed from the marketplace </li> <li>gitStream workflows action that was placed in <code>.github/workflows/gitstream.yml</code> and pulls another runner action from <code>linear-b/gitstream-github-action@v1</code></li> </ol> <p>Once a new PR is opened (or changed) the following process occurs:</p> <ol> <li>gitStream gets event for the new PR </li> <li>gitStream calls the installed action in <code>.github/workflows/gitstream.yml</code></li> <li>The installed action pulls and runs gitStream action <code>linear-b/gitstream-github-action@v1</code>. </li> <li>This action runs locally in the repo and relies on </li> <li>The current branch is used to check which automations are valid from <code>.cm/gitstream.cm</code></li> <li>The list of applicable automations are sent to the gitStream GitHub app</li> <li>gitStream GitHub app iterates over the automations and invokes each action using GitHub APIs</li> <li>The PR gets updated according to the desired automations</li> </ol> <p>At the end, the PR is ready for further review or merge.</p> <p>The following diagram describes the flow:</p> <pre><code>sequenceDiagram\n  autonumber\n  GitHub API-&gt;&gt;gitStream app: new PR\n  gitStream app-&gt;&gt;gitStream workflows actions: run \n  activate gitStream workflows actions\n  gitStream workflows actions-&gt;&gt;gitStream workflows actions: pull runner action\n  gitStream workflows actions-&gt;&gt;gitStream runner action: run\n  activate gitStream runner action\n  gitStream runner action-&gt;&gt;gitStream runner action: parse the `.cm` rules\n  gitStream runner action-&gt;&gt;gitStream app: applicable automations\n  deactivate gitStream runner action\n  deactivate gitStream workflows actions\n  loop per automation\n    loop per action\n      gitStream app-&gt;&gt;gitStream app: execute action\n      gitStream app-&gt;&gt;GitHub API: update PR\n    end\n   end</code></pre>"},{"location":"how-it-works/#the-branch-diff","title":"The branch diff","text":"<p>The branch diff is defined as the difference between the current branch and the most recent commit in the main branch which is shared between both branches.</p> <pre><code>gitGraph\n   commit id: \"A\"\n   commit id: \"B\"\n   branch feature\n   commit id: \"C\"\n   commit id: \"D\"\n   checkout main\n   commit id: \"E\"\n   commit id: \"F\"\n   checkout feature\n   merge main\n   commit id: \"G\"\n   commit id: \"H\"\n   checkout main\n   commit id: \"I\"\n   commit id: \"J\"</code></pre> <p>In the example above, the diff is performed between commits <code>H</code> and <code>F</code>.</p>"},{"location":"how-it-works/#automation-results","title":"Automation results","text":"<p>Eventually, the gitStream app shows the following statuses:  </p> <ul> <li>Success - when the applicable automation finished and PR is good to go </li> <li>Neutral - when there aren't any applicable automations for the PR</li> <li>Failed - when the applicable automation finished without completion</li> </ul>"},{"location":"troubleshooting/","title":"Troubleshooting","text":""},{"location":"troubleshooting/#i-cant-see-any-action-running","title":"I can't see any action running","text":"<p>Did you install gitStream in your repo? Check that you see gitStream app on repository's Settings &gt; GitHub apps:</p> <p> In case you don't see it, visit the marketplace and install it for free: https://github.com/marketplace/gitstream-by-linearb</p> <p>Did you set the workflow files correctly? Check you have placed these 2 files in your repository, with these exact names:  1. <code>.cm/gitstream.cm</code> 2. <code>.github/workflows/gitstream.yml</code></p> <p>These files needs to be commited to the repository default branch (usually <code>master</code> or <code>main</code>).</p> <p>Check that you see \"gitStream workflow automation\" on the Action section in your repository:</p> <p></p>"},{"location":"troubleshooting/#i-cant-set-gitstream-as-required-check","title":"I can't set gitStream as required check","text":"<p>In order for gitStream to be listed as a required check, it needs to be triggered at least once in that repo. First create a new PR so gitStream is triggered.</p> <p>Check it under repository's Settings &gt; Branches: </p> <p></p> <p></p>"}]}